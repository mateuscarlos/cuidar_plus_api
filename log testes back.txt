/app # pytest
ImportError while loading conftest '/app/tests/conftest.py'.
tests/conftest.py:9: in <module>
    from src.app import create_app
E   ModuleNotFoundError: No module named 'src.app'
/app # diagnose.py
/bin/sh: diagnose.py: not found
/app # python diagnose.py
Ambiente Python:
  Versão: 3.13.3 (main, Apr  9 2025, 00:21:38) [GCC 14.2.0]
  Diretório de Execução: /app
  Python Path: ['/app', '/usr/local/lib/python313.zip', '/usr/local/lib/python3.13', '/usr/local/lib/python3.13/lib-dynload', '/usr/local/lib/python3.13/site-packages']

Arquivos em /app:
  [DIR] .git
  [DIR] .github
  [FILE] .gitignore
  [DIR] .idea
  [DIR] .venv
  [DIR] .vs
  [FILE] Analise_Inicial.md
  [FILE] app.py
  [FILE] comandos_docker_compose_do_projeto.md
  [FILE] config.py
  [FILE] db.py
  [FILE] db_drop_all.py
  [FILE] diagnose.py
  [FILE] docker-compose.backend.yml
  [FILE] docker-compose.db.yml
  [FILE] Dockerfile
  [DIR] docs
  [FILE] health.py
  [FILE] homecare_funcoes.py
  [DIR] migrations
  [DIR] models
  [FILE] models.py
  [FILE] pytest.ini
  [FILE] README.md
  [FILE] requirements.txt
  [DIR] routes
  [DIR] scripts
  [DIR] src
  [DIR] tests
  [FILE] users.db
  [FILE] utils.py
  [FILE] wait-for-it.sh
  [DIR] __pycache__

Arquivos em /app/src:
  [DIR] infrastructure
  [DIR] interfaces

Tentando importar 'app':
Banco de dados criado com sucesso.
Tabela 'paciente' criada com sucesso.
Tabela 'acompanhamento' criada com sucesso.
Tabela 'convenio' criada com sucesso.
Tabela 'plano' criada com sucesso.
Tabela 'user' criada com sucesso.
  ✓ Importação bem-sucedida

Tentando importar 'src.app':
  ✗ Erro: No module named 'src.app'

Tentando importar 'db':
  ✓ Importação bem-sucedida

Tentando importar 'src.db':
  ✗ Erro: No module named 'src.db'

Tentando importar 'database':
  ✗ Erro: No module named 'database'

Tentando importar 'src.database':
  ✗ Erro: No module named 'src.database'
/app # ^C

/app # pytest
============================================================================================================================================ test session starts ============================================================================================================================================
platform linux -- Python 3.13.3, pytest-8.3.5, pluggy-1.5.0 -- /usr/local/bin/python3.13
cachedir: .pytest_cache
rootdir: /app
configfile: pytest.ini
testpaths: tests
collected 21 items                                                                                                                                                                                                                                                                                          

tests/integration/test_acompanhamentos_routes.py::test_criar_acompanhamento ERROR                                                                                                                                                                                                                     [  4%]
tests/integration/test_acompanhamentos_routes.py::test_obter_acompanhamentos_por_paciente FAILED                                                                                                                                                                                                      [  9%]
tests/integration/test_acompanhamentos_routes.py::test_atualizar_acompanhamento FAILED                                                                                                                                                                                                                [ 14%]
tests/integration/test_acompanhamentos_routes.py::test_atualizar_acompanhamento ERROR                                                                                                                                                                                                                 [ 14%]
tests/integration/test_convenios_planos.py::test_criar_convenio FAILED                                                                                                                                                                                                                                [ 19%]
tests/integration/test_convenios_planos.py::test_listar_convenios FAILED                                                                                                                                                                                                                              [ 23%]
tests/integration/test_convenios_planos.py::test_listar_convenios ERROR                                                                                                                                                                                                                               [ 23%]
tests/integration/test_pacientes_routes.py::test_criar_paciente PASSED                                                                                                                                                                                                                                [ 28%]
tests/integration/test_pacientes_routes.py::test_obter_paciente FAILED                                                                                                                                                                                                                                [ 33%]
tests/integration/test_pacientes_routes.py::test_atualizar_paciente FAILED                                                                                                                                                                                                                            [ 38%]
tests/integration/test_pacientes_routes.py::test_atualizar_paciente ERROR                                                                                                                                                                                                                             [ 38%]
tests/integration/test_user_routes.py::test_create_user FAILED                                                                                                                                                                                                                                        [ 42%]
tests/integration/test_user_routes.py::test_create_user_missing_fields FAILED                                                                                                                                                                                                                         [ 47%]
tests/integration/test_user_routes.py::test_get_all_users FAILED                                                                                                                                                                                                                                      [ 52%]
tests/integration/test_user_routes.py::test_get_user_by_id FAILED                                                                                                                                                                                                                                     [ 57%]
tests/integration/test_user_routes.py::test_get_nonexistent_user PASSED                                                                                                                                                                                                                               [ 61%]
tests/integration/test_user_routes.py::test_update_user FAILED                                                                                                                                                                                                                                        [ 66%]
tests/integration/test_user_routes.py::test_delete_user FAILED                                                                                                                                                                                                                                        [ 71%]
tests/integration/test_user_routes.py::test_delete_user ERROR                                                                                                                                                                                                                                         [ 71%]
tests/unit/test_models.py::test_user_model FAILED                                                                                                                                                                                                                                                     [ 76%]
tests/unit/test_models.py::test_paciente_model FAILED                                                                                                                                                                                                                                                 [ 80%]
tests/unit/test_models.py::test_acompanhamento_model FAILED                                                                                                                                                                                                                                           [ 85%]
tests/unit/test_utils.py::test_validate_cpf_valid PASSED                                                                                                                                                                                                                                              [ 90%]
tests/unit/test_utils.py::test_validate_cpf_invalid PASSED                                                                                                                                                                                                                                            [ 95%]
tests/unit/test_utils.py::test_sanitize_input FAILED                                                                                                                                                                                                                                                  [100%]

================================================================================================================================================== ERRORS ===================================================================================================================================================
________________________________________________________________________________________________________________________________ ERROR at setup of test_criar_acompanhamento ________________________________________________________________________________________________________________________________
file /app/tests/integration/test_acompanhamentos_routes.py, line 44
  def test_criar_acompanhamento(test_client, create_test_paciente):
E       fixture 'create_test_paciente' not found
>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, clear_db, create_test_paciente_e_acompanhamento, create_test_user, doctest_namespace, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/app/tests/integration/test_acompanhamentos_routes.py:44
____________________________________________________________________________________________________________________________ ERROR at teardown of test_atualizar_acompanhamento _____________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba103fc50>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735ba130ba10>
statement = <sqlalchemy.dialects.mysql.base.MySQLDDLCompiler object at 0x735ba0fa2b10>, parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.OperationalError: (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='module')
    def test_client():
        """Cria um cliente de teste para a aplicação Flask"""
        # Configuração específica para testes
        app.config['TESTING'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'  # SQLite em memória
        app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
        # Cria tabelas no banco de dados de teste
        with app.app_context():
            db.create_all()
    
        # Cria um cliente de teste
        with app.test_client() as client:
            # Estabelece um contexto de aplicação
            with app.app_context():
                yield client
    
        # Limpeza após os testes
        with app.app_context():
            db.session.remove()
>           db.drop_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5953: in drop_all
    bind._run_ddl_visitor(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1139: in visit_metadata
    self.traverse_single(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1206: in visit_table
    DropTable(table)._invoke_with(self.connection)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
E       [SQL: 
E       DROP TABLE setores]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError
________________________________________________________________________________________________________________________________ ERROR at teardown of test_listar_convenios _________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba10bb310>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735ba130aaf0>
statement = <sqlalchemy.dialects.mysql.base.MySQLDDLCompiler object at 0x735ba10ba7b0>, parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.OperationalError: (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='module')
    def test_client():
        """Cria um cliente de teste para a aplicação Flask"""
        # Configuração específica para testes
        app.config['TESTING'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'  # SQLite em memória
        app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
        # Cria tabelas no banco de dados de teste
        with app.app_context():
            db.create_all()
    
        # Cria um cliente de teste
        with app.test_client() as client:
            # Estabelece um contexto de aplicação
            with app.app_context():
                yield client
    
        # Limpeza após os testes
        with app.app_context():
            db.session.remove()
>           db.drop_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5953: in drop_all
    bind._run_ddl_visitor(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1139: in visit_metadata
    self.traverse_single(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1206: in visit_table
    DropTable(table)._invoke_with(self.connection)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
E       [SQL: 
E       DROP TABLE setores]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError
_______________________________________________________________________________________________________________________________ ERROR at teardown of test_atualizar_paciente ________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba2e38910>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735ba130b540>
statement = <sqlalchemy.dialects.mysql.base.MySQLDDLCompiler object at 0x735ba10b6b70>, parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.OperationalError: (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='module')
    def test_client():
        """Cria um cliente de teste para a aplicação Flask"""
        # Configuração específica para testes
        app.config['TESTING'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'  # SQLite em memória
        app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
        # Cria tabelas no banco de dados de teste
        with app.app_context():
            db.create_all()
    
        # Cria um cliente de teste
        with app.test_client() as client:
            # Estabelece um contexto de aplicação
            with app.app_context():
                yield client
    
        # Limpeza após os testes
        with app.app_context():
            db.session.remove()
>           db.drop_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5953: in drop_all
    bind._run_ddl_visitor(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1139: in visit_metadata
    self.traverse_single(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1206: in visit_table
    DropTable(table)._invoke_with(self.connection)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
E       [SQL: 
E       DROP TABLE setores]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError
___________________________________________________________________________________________________________________________________ ERROR at teardown of test_delete_user ___________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a79630>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735b9f6cf120>
statement = <sqlalchemy.dialects.mysql.base.MySQLDDLCompiler object at 0x735ba0a0def0>, parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.OperationalError: (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope='module')
    def test_client():
        """Cria um cliente de teste para a aplicação Flask"""
        # Configuração específica para testes
        app.config['TESTING'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'  # SQLite em memória
        app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
        # Cria tabelas no banco de dados de teste
        with app.app_context():
            db.create_all()
    
        # Cria um cliente de teste
        with app.test_client() as client:
            # Estabelece um contexto de aplicação
            with app.app_context():
                yield client
    
        # Limpeza após os testes
        with app.app_context():
            db.session.remove()
>           db.drop_all()

tests/conftest.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
/usr/local/lib/python3.13/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5953: in drop_all
    bind._run_ddl_visitor(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1139: in visit_metadata
    self.traverse_single(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py:664: in traverse_single
    return meth(obj, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:1206: in visit_table
    DropTable(table)._invoke_with(self.connection)
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1527: in _execute_ddl
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x92\x0e#HY000Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'."

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
E       [SQL: 
E       DROP TABLE setores]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: OperationalError
================================================================================================================================================= FAILURES ==================================================================================================================================================
__________________________________________________________________________________________________________________________________ test_obter_acompanhamentos_por_paciente __________________________________________________________________________________________________________________________________

test_client = <FlaskClient <Flask 'app'>>, create_test_paciente_e_acompanhamento = <function create_test_paciente_e_acompanhamento.<locals>._create at 0x735ba14a25c0>

    def test_obter_acompanhamentos_por_paciente(test_client, create_test_paciente_e_acompanhamento):
        """Testa a obtenção de acompanhamentos de um paciente"""
        dados = create_test_paciente_e_acompanhamento()
        paciente = dados['paciente']
    
>       response = test_client.get(f'/pacientes/{paciente.id}/acompanhamentos')

tests/integration/test_acompanhamentos_routes.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py:566: in __get__
    return self.impl.get(state, dict_)  # type: ignore[no-any-return]
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py:1086: in get
    value = self._fire_loader_callables(state, key, passive)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py:1116: in _fire_loader_callables
    return state._load_expired(state, passive)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state.py:803: in _load_expired
    self.manager.expired_attribute_loader(self, toload, passive)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mapper = <Mapper at 0x735ba324b620; Paciente>, state = <sqlalchemy.orm.state.InstanceState object at 0x735ba302b230>, attribute_names = {'acomodacao', 'acompanhamentos', 'alergias', 'case_responsavel', 'cid_primario', 'cid_secundario', ...}, passive = symbol('PASSIVE_OFF')

    def load_scalar_attributes(mapper, state, attribute_names, passive):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
>           raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
                "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Paciente at 0x735ba12ba3c0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: https://sqlalche.me/e/20/bhk3)

/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:1603: DetachedInstanceError
_______________________________________________________________________________________________________________________________________ test_atualizar_acompanhamento _______________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba103f3e0>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735ba130a200>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba0f8de50>, parameters = [{'acomodacao': 'Apartamento', 'alergias': None, 'case_responsavel': None, 'cid_primario': 'I10', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff&\x04#23000Duplicate entry '55566677788' for key 'paciente.cpf'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry '55566677788' for key 'paciente.cpf'")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError

The above exception was the direct cause of the following exception:

test_client = <FlaskClient <Flask 'app'>>, create_test_paciente_e_acompanhamento = <function create_test_paciente_e_acompanhamento.<locals>._create at 0x735ba1099440>

    def test_atualizar_acompanhamento(test_client, create_test_paciente_e_acompanhamento):
        """Testa a atualização de um acompanhamento"""
>       dados = create_test_paciente_e_acompanhamento()

tests/integration/test_acompanhamentos_routes.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/integration/test_acompanhamentos_routes.py:28: in _create
    db.session.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff&\x04#23000Duplicate entry '55566677788' for key 'paciente.cpf'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry '55566677788' for key 'paciente.cpf'")
E       [SQL: INSERT INTO paciente (nome_completo, cpf, convenio_id, plano_id, numero_carteirinha, acomodacao, telefone, telefone_secundario, email, alergias, cid_primario, cid_secundario, data_nascimento, endereco_json, status, genero, estado_civil, profissao, nacionalidade, data_validade, contato_emergencia, telefone_emergencia, case_responsavel, medico_responsavel, created_at, updated_at) VALUES (%(nome_completo)s, %(cpf)s, %(convenio_id)s, %(plano_id)s, %(numero_carteirinha)s, %(acomodacao)s, %(telefone)s, %(telefone_secundario)s, %(email)s, %(alergias)s, %(cid_primario)s, %(cid_secundario)s, %(data_nascimento)s, %(endereco_json)s, %(status)s, %(genero)s, %(estado_civil)s, %(profissao)s, %(nacionalidade)s, %(data_validade)s, %(contato_emergencia)s, %(telefone_emergencia)s, %(case_responsavel)s, %(medico_responsavel)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'nome_completo': 'Roberto Acompanhamento', 'cpf': '55566677788', 'convenio_id': None, 'plano_id': None, 'numero_carteirinha': None, 'acomodacao': 'Apartamento', 'telefone': '(11) 98888-7777', 'telefone_secundario': None, 'email': None, 'alergias': None, 'cid_primario': 'I10', 'cid_secundario': None, 'data_nascimento': datetime.date(1970, 10, 20), 'endereco_json': None, 'status': 'em-avaliacao', 'genero': None, 'estado_civil': None, 'profissao': None, 'nacionalidade': 'Brasileiro(a)', 'data_validade': None, 'contato_emergencia': None, 'telefone_emergencia': None, 'case_responsavel': None, 'medico_responsavel': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 7, 446445), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 7, 446472)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError
____________________________________________________________________________________________________________________________________________ test_criar_convenio ____________________________________________________________________________________________________________________________________________

test_client = <FlaskClient <Flask 'app'>>

    def test_criar_convenio(test_client):
        """Testa a criação de um convênio"""
        dados_convenio = {
            'nome': 'MedPlus',
            'contato': '(11) 2222-3333'
        }
    
        response = test_client.post('/convenios', json=dados_convenio)
    
>       assert response.status_code == 201
E       assert 404 == 201
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/integration/test_convenios_planos.py:53: AssertionError
___________________________________________________________________________________________________________________________________________ test_listar_convenios ___________________________________________________________________________________________________________________________________________

test_client = <FlaskClient <Flask 'app'>>, create_test_convenio = <function create_test_convenio.<locals>._create_convenio at 0x735ba10b72e0>

    def test_listar_convenios(test_client, create_test_convenio):
        """Testa a listagem de convênios"""
>       create_test_convenio(nome='Convênio 1')

tests/integration/test_convenios_planos.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/integration/test_convenios_planos.py:17: in _create_convenio
    convenio = Convenio(
<string>:4: in __init__
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Convenio (transient 126837374648736)>, kwargs = {'contato': '(11) 3333-4444', 'nome': 'Convênio 1'}, cls_ = <class 'models.convenio.Convenio'>, k = 'contato'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'contato' is an invalid keyword argument for Convenio

/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/decl_base.py:2175: TypeError
____________________________________________________________________________________________________________________________________________ test_obter_paciente ____________________________________________________________________________________________________________________________________________

test_client = <FlaskClient <Flask 'app'>>, create_test_paciente = <function create_test_paciente.<locals>._create_paciente at 0x735ba0a0c400>

    def test_obter_paciente(test_client, create_test_paciente):
        """Testa a obtenção de um paciente pelo ID"""
        paciente = create_test_paciente()
    
>       response = test_client.get(f'/pacientes/buscar/{paciente.id}')

tests/integration/test_pacientes_routes.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py:566: in __get__
    return self.impl.get(state, dict_)  # type: ignore[no-any-return]
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py:1086: in get
    value = self._fire_loader_callables(state, key, passive)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py:1116: in _fire_loader_callables
    return state._load_expired(state, passive)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state.py:803: in _load_expired
    self.manager.expired_attribute_loader(self, toload, passive)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mapper = <Mapper at 0x735ba324b620; Paciente>, state = <sqlalchemy.orm.state.InstanceState object at 0x735b9fd933b0>, attribute_names = {'acomodacao', 'acompanhamentos', 'alergias', 'case_responsavel', 'cid_primario', 'cid_secundario', ...}, passive = symbol('PASSIVE_OFF')

    def load_scalar_attributes(mapper, state, attribute_names, passive):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
>           raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
                "attribute refresh operation cannot proceed" % (state_str(state))
            )
E           sqlalchemy.orm.exc.DetachedInstanceError: Instance <Paciente at 0x735ba113d590> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: https://sqlalche.me/e/20/bhk3)

/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:1603: DetachedInstanceError
__________________________________________________________________________________________________________________________________________ test_atualizar_paciente __________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a975b0>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735ba130ba10>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba0f8de50>, parameters = [{'acomodacao': 'Apartamento', 'alergias': None, 'case_responsavel': None, 'cid_primario': 'G40', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff&\x04#23000Duplicate entry '12345678901' for key 'paciente.cpf'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry '12345678901' for key 'paciente.cpf'")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError

The above exception was the direct cause of the following exception:

test_client = <FlaskClient <Flask 'app'>>, create_test_paciente = <function create_test_paciente.<locals>._create_paciente at 0x735ba0a0c360>

    def test_atualizar_paciente(test_client, create_test_paciente):
        """Testa a atualização de um paciente"""
>       paciente = create_test_paciente()

tests/integration/test_pacientes_routes.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/integration/test_pacientes_routes.py:26: in _create_paciente
    db.session.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff&\x04#23000Duplicate entry '12345678901' for key 'paciente.cpf'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry '12345678901' for key 'paciente.cpf'")
E       [SQL: INSERT INTO paciente (nome_completo, cpf, convenio_id, plano_id, numero_carteirinha, acomodacao, telefone, telefone_secundario, email, alergias, cid_primario, cid_secundario, data_nascimento, endereco_json, status, genero, estado_civil, profissao, nacionalidade, data_validade, contato_emergencia, telefone_emergencia, case_responsavel, medico_responsavel, created_at, updated_at) VALUES (%(nome_completo)s, %(cpf)s, %(convenio_id)s, %(plano_id)s, %(numero_carteirinha)s, %(acomodacao)s, %(telefone)s, %(telefone_secundario)s, %(email)s, %(alergias)s, %(cid_primario)s, %(cid_secundario)s, %(data_nascimento)s, %(endereco_json)s, %(status)s, %(genero)s, %(estado_civil)s, %(profissao)s, %(nacionalidade)s, %(data_validade)s, %(contato_emergencia)s, %(telefone_emergencia)s, %(case_responsavel)s, %(medico_responsavel)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'nome_completo': 'José da Silva', 'cpf': '12345678901', 'convenio_id': None, 'plano_id': None, 'numero_carteirinha': None, 'acomodacao': 'Apartamento', 'telefone': '(11) 98765-4321', 'telefone_secundario': None, 'email': None, 'alergias': None, 'cid_primario': 'G40', 'cid_secundario': None, 'data_nascimento': datetime.date(1980, 1, 1), 'endereco_json': None, 'status': 'em-avaliacao', 'genero': None, 'estado_civil': None, 'profissao': None, 'nacionalidade': 'Brasileiro(a)', 'data_validade': None, 'contato_emergencia': None, 'telefone_emergencia': None, 'case_responsavel': None, 'medico_responsavel': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 11, 851017), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 11, 851040)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError
_____________________________________________________________________________________________________________________________________________ test_create_user ______________________________________________________________________________________________________________________________________________

test_client = <FlaskClient <Flask 'app'>>

    def test_create_user(test_client):
        """Testa a criação de um novo usuário"""
        response = test_client.post('/api/users',
            json={'nome': 'Maria Santos', 'cpf': '98765432101', 'setor': 'Administração', 'funcao': 'Gerente'})
    
>       assert response.status_code == 201
E       assert 404 == 201
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/integration/test_user_routes.py:14: AssertionError
______________________________________________________________________________________________________________________________________ test_create_user_missing_fields ______________________________________________________________________________________________________________________________________

test_client = <FlaskClient <Flask 'app'>>

    def test_create_user_missing_fields(test_client):
        """Testa a criação de usuário com campos obrigatórios faltando"""
        response = test_client.post('/api/users', json={'nome': 'João Incompleto'})
    
>       assert response.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/integration/test_user_routes.py:24: AssertionError
____________________________________________________________________________________________________________________________________________ test_get_all_users _____________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a349f0>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735b9f6cc310>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba113ca50>, parameters = [{'_endereco': None, '_permissions': None, 'cargo': None, 'cep': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1048, "Column 'email' cannot be null")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError

The above exception was the direct cause of the following exception:

test_client = <FlaskClient <Flask 'app'>>, create_test_user = <function create_test_user.<locals>._create_user at 0x735ba0a0ce00>

    def test_get_all_users(test_client, create_test_user):
        """Testa a obtenção de todos os usuários"""
        # Cria alguns usuários para teste
>       create_test_user(nome='Usuário 1', cpf='12345678901')

tests/integration/test_user_routes.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/conftest.py:50: in _create_user
    db.session.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
E       [SQL: INSERT INTO user (nome, email, password_hash, cargo, cpf, cep, _endereco, setor, funcao, especialidade, registro_categoria, telefone, data_admissao, status, tipo_acesso, _permissions, created_at, updated_at, tipo_contratacao) VALUES (%(nome)s, %(email)s, %(password_hash)s, %(cargo)s, %(cpf)s, %(cep)s, %(_endereco)s, %(setor)s, %(funcao)s, %(especialidade)s, %(registro_categoria)s, %(telefone)s, %(data_admissao)s, %(status)s, %(tipo_acesso)s, %(_permissions)s, %(created_at)s, %(updated_at)s, %(tipo_contratacao)s)]
E       [parameters: {'nome': 'Usuário 1', 'email': None, 'password_hash': None, 'cargo': None, 'cpf': '12345678901', 'cep': None, '_endereco': None, 'setor': 'TI', 'funcao': 'Desenvolvedor', 'especialidade': None, 'registro_categoria': None, 'telefone': None, 'data_admissao': None, 'status': 'Ativo', 'tipo_acesso': None, '_permissions': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 14, 319916), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 14, 319956), 'tipo_contratacao': None}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError
____________________________________________________________________________________________________________________________________________ test_get_user_by_id ____________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a3c590>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735ba130a150>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba113ca50>, parameters = [{'_endereco': None, '_permissions': None, 'cargo': None, 'cep': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1048, "Column 'email' cannot be null")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError

The above exception was the direct cause of the following exception:

test_client = <FlaskClient <Flask 'app'>>, create_test_user = <function create_test_user.<locals>._create_user at 0x735ba10b6700>

    def test_get_user_by_id(test_client, create_test_user):
        """Testa a obtenção de um usuário específico pelo ID"""
>       user = create_test_user(nome='Carlos Silva', cpf='44455566677')

tests/integration/test_user_routes.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/conftest.py:50: in _create_user
    db.session.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
E       [SQL: INSERT INTO user (nome, email, password_hash, cargo, cpf, cep, _endereco, setor, funcao, especialidade, registro_categoria, telefone, data_admissao, status, tipo_acesso, _permissions, created_at, updated_at, tipo_contratacao) VALUES (%(nome)s, %(email)s, %(password_hash)s, %(cargo)s, %(cpf)s, %(cep)s, %(_endereco)s, %(setor)s, %(funcao)s, %(especialidade)s, %(registro_categoria)s, %(telefone)s, %(data_admissao)s, %(status)s, %(tipo_acesso)s, %(_permissions)s, %(created_at)s, %(updated_at)s, %(tipo_contratacao)s)]
E       [parameters: {'nome': 'Carlos Silva', 'email': None, 'password_hash': None, 'cargo': None, 'cpf': '44455566677', 'cep': None, '_endereco': None, 'setor': 'TI', 'funcao': 'Desenvolvedor', 'especialidade': None, 'registro_categoria': None, 'telefone': None, 'data_admissao': None, 'status': 'Ativo', 'tipo_acesso': None, '_permissions': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 15, 457266), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 15, 457293), 'tipo_contratacao': None}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError
_____________________________________________________________________________________________________________________________________________ test_update_user ______________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a2dd30>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735b9f6cdde0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba113ca50>, parameters = [{'_endereco': None, '_permissions': None, 'cargo': None, 'cep': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1048, "Column 'email' cannot be null")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError

The above exception was the direct cause of the following exception:

test_client = <FlaskClient <Flask 'app'>>, create_test_user = <function create_test_user.<locals>._create_user at 0x735ba0a0f740>

    def test_update_user(test_client, create_test_user):
        """Testa a atualização de um usuário"""
>       user = create_test_user(nome='Antigo Nome', cpf='11122233344')

tests/integration/test_user_routes.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/conftest.py:50: in _create_user
    db.session.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
E       [SQL: INSERT INTO user (nome, email, password_hash, cargo, cpf, cep, _endereco, setor, funcao, especialidade, registro_categoria, telefone, data_admissao, status, tipo_acesso, _permissions, created_at, updated_at, tipo_contratacao) VALUES (%(nome)s, %(email)s, %(password_hash)s, %(cargo)s, %(cpf)s, %(cep)s, %(_endereco)s, %(setor)s, %(funcao)s, %(especialidade)s, %(registro_categoria)s, %(telefone)s, %(data_admissao)s, %(status)s, %(tipo_acesso)s, %(_permissions)s, %(created_at)s, %(updated_at)s, %(tipo_contratacao)s)]
E       [parameters: {'nome': 'Antigo Nome', 'email': None, 'password_hash': None, 'cargo': None, 'cpf': '11122233344', 'cep': None, '_endereco': None, 'setor': 'TI', 'funcao': 'Desenvolvedor', 'especialidade': None, 'registro_categoria': None, 'telefone': None, 'data_admissao': None, 'status': 'Ativo', 'tipo_acesso': None, '_permissions': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 16, 499793), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 16, 499812), 'tipo_contratacao': None}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError
_____________________________________________________________________________________________________________________________________________ test_delete_user ______________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a2eb30>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735b9f6ce6d0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba113ca50>, parameters = [{'_endereco': None, '_permissions': None, 'cargo': None, 'cep': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1048, "Column 'email' cannot be null")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError

The above exception was the direct cause of the following exception:

test_client = <FlaskClient <Flask 'app'>>, create_test_user = <function create_test_user.<locals>._create_user at 0x735ba0a0ee80>

    def test_delete_user(test_client, create_test_user):
        """Testa a exclusão de um usuário"""
>       user = create_test_user()

tests/integration/test_user_routes.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/conftest.py:50: in _create_user
    db.session.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
E       [SQL: INSERT INTO user (nome, email, password_hash, cargo, cpf, cep, _endereco, setor, funcao, especialidade, registro_categoria, telefone, data_admissao, status, tipo_acesso, _permissions, created_at, updated_at, tipo_contratacao) VALUES (%(nome)s, %(email)s, %(password_hash)s, %(cargo)s, %(cpf)s, %(cep)s, %(_endereco)s, %(setor)s, %(funcao)s, %(especialidade)s, %(registro_categoria)s, %(telefone)s, %(data_admissao)s, %(status)s, %(tipo_acesso)s, %(_permissions)s, %(created_at)s, %(updated_at)s, %(tipo_contratacao)s)]
E       [parameters: {'nome': 'João da Silva', 'email': None, 'password_hash': None, 'cargo': None, 'cpf': '12345678909', 'cep': None, '_endereco': None, 'setor': 'TI', 'funcao': 'Desenvolvedor', 'especialidade': None, 'registro_categoria': None, 'telefone': None, 'data_admissao': None, 'status': 'Ativo', 'tipo_acesso': None, '_permissions': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 17, 586376), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 17, 586386), 'tipo_contratacao': None}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError
______________________________________________________________________________________________________________________________________________ test_user_model ______________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a7a5f0>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735b9f6cda70>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba113ca50>, parameters = [{'_endereco': None, '_permissions': None, 'cargo': None, 'cep': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1048, "Column 'email' cannot be null")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError

The above exception was the direct cause of the following exception:

    def test_user_model():
        """Testa criação e atributos do modelo User"""
        with app.app_context():
            user = User(
                nome='Ana Testes',
                cpf='98765432100',
                setor='Enfermagem',
                funcao='Enfermeira'
            )
            db.session.add(user)
>           db.session.commit()

tests/unit/test_models.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x18\x04#23000Column 'email' cannot be null"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
E       [SQL: INSERT INTO user (nome, email, password_hash, cargo, cpf, cep, _endereco, setor, funcao, especialidade, registro_categoria, telefone, data_admissao, status, tipo_acesso, _permissions, created_at, updated_at, tipo_contratacao) VALUES (%(nome)s, %(email)s, %(password_hash)s, %(cargo)s, %(cpf)s, %(cep)s, %(_endereco)s, %(setor)s, %(funcao)s, %(especialidade)s, %(registro_categoria)s, %(telefone)s, %(data_admissao)s, %(status)s, %(tipo_acesso)s, %(_permissions)s, %(created_at)s, %(updated_at)s, %(tipo_contratacao)s)]
E       [parameters: {'nome': 'Ana Testes', 'email': None, 'password_hash': None, 'cargo': None, 'cpf': '98765432100', 'cep': None, '_endereco': None, 'setor': 'Enfermagem', 'funcao': 'Enfermeira', 'especialidade': None, 'registro_categoria': None, 'telefone': None, 'data_admissao': None, 'status': 'Ativo', 'tipo_acesso': None, '_permissions': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 19, 589289), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 19, 589312), 'tipo_contratacao': None}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: IntegrityError
____________________________________________________________________________________________________________________________________________ test_paciente_model ____________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba0a7b4d0>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735b9f6cf330>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba0f8de50>, parameters = [{'acomodacao': 'Apartamento', 'alergias': None, 'case_responsavel': None, 'cid_primario': 'G40', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xffz\x04#42S02Table 'cuidar_plus_bd.paciente' doesn't exist"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.ProgrammingError: (1146, "Table 'cuidar_plus_bd.paciente' doesn't exist")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: ProgrammingError

The above exception was the direct cause of the following exception:

    def test_paciente_model():
        """Testa criação e atributos do modelo Paciente"""
        with app.app_context():
            paciente = Paciente(
                nome_completo='Carlos Paciente',
                cpf='11122233344',
                data_nascimento=date(1980, 5, 15),
                acomodacao='Apartamento',
                telefone='(11) 98765-4321',
                cid_primario='G40'
            )
            db.session.add(paciente)
>           db.session.commit()

tests/unit/test_models.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xffz\x04#42S02Table 'cuidar_plus_bd.paciente' doesn't exist"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.ProgrammingError: (pymysql.err.ProgrammingError) (1146, "Table 'cuidar_plus_bd.paciente' doesn't exist")
E       [SQL: INSERT INTO paciente (nome_completo, cpf, convenio_id, plano_id, numero_carteirinha, acomodacao, telefone, telefone_secundario, email, alergias, cid_primario, cid_secundario, data_nascimento, endereco_json, status, genero, estado_civil, profissao, nacionalidade, data_validade, contato_emergencia, telefone_emergencia, case_responsavel, medico_responsavel, created_at, updated_at) VALUES (%(nome_completo)s, %(cpf)s, %(convenio_id)s, %(plano_id)s, %(numero_carteirinha)s, %(acomodacao)s, %(telefone)s, %(telefone_secundario)s, %(email)s, %(alergias)s, %(cid_primario)s, %(cid_secundario)s, %(data_nascimento)s, %(endereco_json)s, %(status)s, %(genero)s, %(estado_civil)s, %(profissao)s, %(nacionalidade)s, %(data_validade)s, %(contato_emergencia)s, %(telefone_emergencia)s, %(case_responsavel)s, %(medico_responsavel)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'nome_completo': 'Carlos Paciente', 'cpf': '11122233344', 'convenio_id': None, 'plano_id': None, 'numero_carteirinha': None, 'acomodacao': 'Apartamento', 'telefone': '(11) 98765-4321', 'telefone_secundario': None, 'email': None, 'alergias': None, 'cid_primario': 'G40', 'cid_secundario': None, 'data_nascimento': datetime.date(1980, 5, 15), 'endereco_json': None, 'status': 'em-avaliacao', 'genero': None, 'estado_civil': None, 'profissao': None, 'nacionalidade': 'Brasileiro(a)', 'data_validade': None, 'contato_emergencia': None, 'telefone_emergencia': None, 'case_responsavel': None, 'medico_responsavel': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 20, 531283), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 20, 531301)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: ProgrammingError
_________________________________________________________________________________________________________________________________________ test_acompanhamento_model _________________________________________________________________________________________________________________________________________

self = <sqlalchemy.engine.base.Connection object at 0x735ba07cd7f0>, dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x735ba1468980>, context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x735b9f6cfd80>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x735ba0f8de50>, parameters = [{'acomodacao': 'Enfermaria', 'alergias': None, 'case_responsavel': None, 'cid_primario': 'I10', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xffz\x04#42S02Table 'cuidar_plus_bd.paciente' doesn't exist"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.ProgrammingError: (1146, "Table 'cuidar_plus_bd.paciente' doesn't exist")

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: ProgrammingError

The above exception was the direct cause of the following exception:

    def test_acompanhamento_model():
        """Testa criação e atributos do modelo Acompanhamento"""
        with app.app_context():
            # Primeiro criamos um paciente para associar
            paciente = Paciente(
                nome_completo='Maria Acompanhamento',
                cpf='44455566677',
                data_nascimento=date(1975, 3, 10),
                acomodacao='Enfermaria',
                telefone='(11) 91234-5678',
                cid_primario='I10'
            )
            db.session.add(paciente)
>           db.session.commit()

tests/unit/test_models.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py:599: in commit
    return self._proxied.commit()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4353: in flush
    self._flush(objects)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/usr/local/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
/usr/local/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: in do_execute
    cursor.execute(statement, parameters)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:153: in execute
    result = self._query(query)
/usr/local/lib/python3.13/site-packages/pymysql/cursors.py:322: in _query
    conn.query(q)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:563: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:825: in _read_query_result
    result.read()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:1199: in read
    first_packet = self.connection._read_packet()
/usr/local/lib/python3.13/site-packages/pymysql/connections.py:775: in _read_packet
    packet.raise_for_error()
/usr/local/lib/python3.13/site-packages/pymysql/protocol.py:219: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xffz\x04#42S02Table 'cuidar_plus_bd.paciente' doesn't exist"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        # https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_err_packet.html
        # Error packet has optional sqlstate that is 5 bytes and starts with '#'.
        if data[3] == 0x23:  # '#'
            # sqlstate = data[4:9].decode()
            # TODO: Append (sqlstate) in the error message. This will be come in next minor release.
            errval = data[9:].decode("utf-8", "replace")
        else:
            errval = data[3:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.ProgrammingError: (pymysql.err.ProgrammingError) (1146, "Table 'cuidar_plus_bd.paciente' doesn't exist")
E       [SQL: INSERT INTO paciente (nome_completo, cpf, convenio_id, plano_id, numero_carteirinha, acomodacao, telefone, telefone_secundario, email, alergias, cid_primario, cid_secundario, data_nascimento, endereco_json, status, genero, estado_civil, profissao, nacionalidade, data_validade, contato_emergencia, telefone_emergencia, case_responsavel, medico_responsavel, created_at, updated_at) VALUES (%(nome_completo)s, %(cpf)s, %(convenio_id)s, %(plano_id)s, %(numero_carteirinha)s, %(acomodacao)s, %(telefone)s, %(telefone_secundario)s, %(email)s, %(alergias)s, %(cid_primario)s, %(cid_secundario)s, %(data_nascimento)s, %(endereco_json)s, %(status)s, %(genero)s, %(estado_civil)s, %(profissao)s, %(nacionalidade)s, %(data_validade)s, %(contato_emergencia)s, %(telefone_emergencia)s, %(case_responsavel)s, %(medico_responsavel)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'nome_completo': 'Maria Acompanhamento', 'cpf': '44455566677', 'convenio_id': None, 'plano_id': None, 'numero_carteirinha': None, 'acomodacao': 'Enfermaria', 'telefone': '(11) 91234-5678', 'telefone_secundario': None, 'email': None, 'alergias': None, 'cid_primario': 'I10', 'cid_secundario': None, 'data_nascimento': datetime.date(1975, 3, 10), 'endereco_json': None, 'status': 'em-avaliacao', 'genero': None, 'estado_civil': None, 'profissao': None, 'nacionalidade': 'Brasileiro(a)', 'data_validade': None, 'contato_emergencia': None, 'telefone_emergencia': None, 'case_responsavel': None, 'medico_responsavel': None, 'created_at': datetime.datetime(2025, 4, 13, 14, 30, 21, 542334), 'updated_at': datetime.datetime(2025, 4, 13, 14, 30, 21, 542344)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

/usr/local/lib/python3.13/site-packages/pymysql/err.py:150: ProgrammingError
____________________________________________________________________________________________________________________________________________ test_sanitize_input ____________________________________________________________________________________________________________________________________________

    def test_sanitize_input():
        """Testa limpeza de inputs"""
        # Remove caracteres especiais
>       assert sanitize_input("abc123!@#") == "abc123"
E       AssertionError: assert 'abc123!@#' == 'abc123'
E         
E         - abc123
E         + abc123!@#
E         ?       +++

tests/unit/test_utils.py:31: AssertionError
============================================================================================================================================= warnings summary ==============================================================================================================================================
tests/integration/test_acompanhamentos_routes.py: 6 warnings
tests/integration/test_pacientes_routes.py: 6 warnings
tests/integration/test_user_routes.py: 8 warnings
tests/unit/test_models.py: 6 warnings
  /usr/local/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:3625: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    return util.wrap_callable(lambda ctx: fn(), fn)  # type: ignore

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
========================================================================================================================================== short test summary info ==========================================================================================================================================
FAILED tests/integration/test_acompanhamentos_routes.py::test_obter_acompanhamentos_por_paciente - sqlalchemy.orm.exc.DetachedInstanceError: Instance <Paciente at 0x735ba12ba3c0> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: https://sqlalche.me/e/20/bhk3)
FAILED tests/integration/test_acompanhamentos_routes.py::test_atualizar_acompanhamento - sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry '55566677788' for key 'paciente.cpf'")
FAILED tests/integration/test_convenios_planos.py::test_criar_convenio - assert 404 == 201
FAILED tests/integration/test_convenios_planos.py::test_listar_convenios - TypeError: 'contato' is an invalid keyword argument for Convenio
FAILED tests/integration/test_pacientes_routes.py::test_obter_paciente - sqlalchemy.orm.exc.DetachedInstanceError: Instance <Paciente at 0x735ba113d590> is not bound to a Session; attribute refresh operation cannot proceed (Background on this error at: https://sqlalche.me/e/20/bhk3)
FAILED tests/integration/test_pacientes_routes.py::test_atualizar_paciente - sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry '12345678901' for key 'paciente.cpf'")
FAILED tests/integration/test_user_routes.py::test_create_user - assert 404 == 201
FAILED tests/integration/test_user_routes.py::test_create_user_missing_fields - assert 404 == 400
FAILED tests/integration/test_user_routes.py::test_get_all_users - sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
FAILED tests/integration/test_user_routes.py::test_get_user_by_id - sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
FAILED tests/integration/test_user_routes.py::test_update_user - sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
FAILED tests/integration/test_user_routes.py::test_delete_user - sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
FAILED tests/unit/test_models.py::test_user_model - sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1048, "Column 'email' cannot be null")
FAILED tests/unit/test_models.py::test_paciente_model - sqlalchemy.exc.ProgrammingError: (pymysql.err.ProgrammingError) (1146, "Table 'cuidar_plus_bd.paciente' doesn't exist")
FAILED tests/unit/test_models.py::test_acompanhamento_model - sqlalchemy.exc.ProgrammingError: (pymysql.err.ProgrammingError) (1146, "Table 'cuidar_plus_bd.paciente' doesn't exist")
FAILED tests/unit/test_utils.py::test_sanitize_input - AssertionError: assert 'abc123!@#' == 'abc123'
ERROR tests/integration/test_acompanhamentos_routes.py::test_criar_acompanhamento
ERROR tests/integration/test_acompanhamentos_routes.py::test_atualizar_acompanhamento - sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
ERROR tests/integration/test_convenios_planos.py::test_listar_convenios - sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
ERROR tests/integration/test_pacientes_routes.py::test_atualizar_paciente - sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
ERROR tests/integration/test_user_routes.py::test_delete_user - sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (3730, "Cannot drop table 'setores' referenced by a foreign key constraint 'fk_user_setor' on table 'user'.")
=========================================================================================================================== 16 failed, 4 passed, 26 warnings, 5 errors in 20.54s ============================================================================================================================
/app # 